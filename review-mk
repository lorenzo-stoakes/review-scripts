#!/bin/bash
set -e; set -o pipefail; source __review-shared.sh
set -m # For job control.

unset nosym
if [[ "$1" == "__NO_SYM" ]]; then
	shift
	nosym=yes
fi

push_kernel_root_dir

UNFINISHED_JOBS_GLOB="unfinished jobs...."

# Cleanup anything left behind.
function cleanup()
{
	rm -f $flag_file
}

# stderr is piped to this function in a subshell.
function do_stderr()
{
	unset pid
	while IFS= read -r line; do
		# First line is the PID of the topmost make command.
		if [[ -z "$pid" ]]; then
			pid=$line
			continue
		fi

		# Spurious output, carry on.
		if [[ "$line" =~ "warning: unsafe" ]] || \
			   [[ "$line" =~ "disassembly will be unreliable" ]] || \
			   [[ "$line" =~ "dtbo" ]]; then
			echo $line >&2
			continue
		fi

		# OK we hit an error, stop the stdout output.
		touch "$flag_file"

		# If we are at the end of meaningful stderr output, kill the
		# build...
		if [[ "$line" =~ "${UNFINISHED_JOBS_GLOB}" ]]; then
			# Stop the build immediately & exit.
			kill $pid
			exit 1
		fi

		# ...Otherwise simply output the next stderr line.
		echo "$line" >&2
	done
}

# stdout is piped to this function in a subshell.
function do_stdout()
{
	while IFS= read -r line; do
		if [[ -e "$flag_file" ]]; then
			# Drain pipe & exit.
			cat > /dev/null
			break
		fi

		echo "$line"
	done
}

# Hack to grab PID in truly hideous fashion.
function cmd()
{
	local kcflags="-fdiagnostics-color=always"

	# We turned on job control with set -m, put build into background...
	# (also force colour output even when piped.)
	if [[ -n "$nosym" ]]; then
		do_build_nosym KCFLAGS="$kcflags" $@ &
	else
		do_build KCFLAGS="$kcflags" $@ &
	fi
	# ...grab PID and output to stderr...
	echo $! >&2
	# ...then foreground right away.
	fg
}

flag_file=$(mktemp -u)
trap cleanup EXIT
cmd $@ 2> >(do_stderr) 1> >(do_stdout)
scripts/clang-tools/gen_compile_commands.py || true
